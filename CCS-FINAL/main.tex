 \documentclass[sigconf]{acmart}

\newif\ifcameraready
\newif\ifeprint

% temporarily set both to true
\camerareadytrue
% \camerareadyfalse
\eprintfalse
% \eprintfalse

%%% True definitions here:

\ifcameraready
 \ifeprint % show both
  \newcommand\eprint[1]{{\color{purple}#1}}
  \newcommand\cameraready[1]{{\color{orange}#1}}
 \else % only cameraready
  \newcommand\cameraready[1]{#1}
  \newcommand\eprint[1]\relax
 \fi
\else % cameraready = false
\ifeprint
 \newcommand\eprint[1]{#1}
 \newcommand\cameraready[1]\relax
\else
 \typeout{Neither cameraready nor eprint set to true}
\fi
\fi

%\usepackage{mdframed}
\usepackage{nicefrac}
\usepackage{csquotes}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{mleftright}
\usepackage{multirow}
\usepackage{aliascnt}
\usepackage[adversary,sets,asymptotics,landau,lambda,operators,logic]{cryptocode}
\usepackage{subcaption}
\usepackage{tablefootnote}
\allowdisplaybreaks
\makeatletter
\makeatother
%\usepackage{tikz}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\subsubsectionautorefname{Section}
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{remark}[theorem]{Remark}
\let\definition\relax
\newaliascnt{definition}{theorem}
\newtheorem{definition}[definition]{Definition}
\aliascntresetthe{definition}
\def\definitionautorefname{Definition}
\theoremstyle{acmplain}
\let\lemma\relax
\newaliascnt{lemma}{theorem}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}
\def\lemmaautorefname{Lemma}
\newaliascnt{claim}{theorem}
\newtheorem{claim}[claim]{Claim}
\aliascntresetthe{claim}
\def\claimautorefname{Claim}
}

\preto\tabular{\setcounter{magicrownumbers}{0}}
\newcounter{magicrownumbers}
\newcommand\rownumber{\stepcounter{magicrownumbers}\arabic{magicrownumbers}}

\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother

%% Load macros
\input{commanddefs}

\title{Chipmunk: Better Synchronized Multi-Signatures from Lattices}

\author{Nils Fleischhacker}
\orcid{0000-0002-2770-5444}
\affiliation{
  \institution{Ruhr University Bochum}
  \city{Bochum}
  \country{Germany}
}
\email{mail@nilsfleischhacker.de}
\author{Gottfried Herold}
\orcid{0009-0005-7089-0883}
\affiliation{
  \institution{Ethereum Foundation}
  \city{Bonn}
  \country{Germany}
}
\email{gottfried.herold@ethereum.org}
\author{Mark Simkin}
\orcid{0000-0002-7325-5261}
\affiliation{
  \institution{Ethereum Foundation}
  \city{Aarhus}
  \country{Denmark}
}
\email{mark.simkin@ethereum.org}
\author{Zhenfei Zhang}
\orcid{0000-0001-5131-5377}
\affiliation{
  \institution{Ethereum Foundation}
  \city{Boston}
  \country{USA}
}
\email{zhenfei.zhang@ethereum.org}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10002978.10002979.10002981.10011602</concept_id>
       <concept_desc>Security and privacy~Digital signatures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Security and privacy~Digital signatures}
\keywords{multi-signatures, lattice based cryptography}

%% Document start
\begin{document}


%% Abstract
\begin{abstract}
Multi-signatures allow for compressing many signatures for the same message that were generated under independent keys into one small aggregated signature. 
This primitive is particularly useful for proof-of-stake blockchains, like Ethereum, where the same block is signed by many signers, who vouch for the block's validity.
Being able to compress all signatures for the same block into a short string significantly reduces the on-chain storage costs, which is an important efficiency metric for blockchains.

In this work, we consider multi-signatures in the synchronized setting, where the signing algorithm takes an additional time parameter as input and it is only required that signatures for the same time step are aggregatable.
The synchronized setting is simpler than the general multi-signature setting, but is sufficient for most blockchain related applications, as signers are naturally synchronized by the length of the chain.

We present Chipmunk, a concretely efficient lattice-based multi-signature scheme in the synchronized setting that allows for signing an a-priori bounded number of messages.
Chipmunk allows for non-interactive aggregation of signatures and is secure against rogue-key attacks.
The construction is plausibly secure against quantum adversaries as our security relies on the assumed hardness of the short integer solution problem.

We significantly improve upon the previously best known construction in this setting by Fleischhacker, Simkin, Zhang (CCS 2022).
Our aggregate signature size is $5 \times$ smaller and for $112$ bits of security our construction allows for compressing 8192 individual signatures into a multi-signature of size less than $200$ KB.
We provide a full implementation of Chipmunk and provide extensive benchmarks studying our construction's efficiency.

\end{abstract}
\maketitle

%% Paper sections
\input{sections/intro}
\input{sections/prelim}
\input{sections/veccom}
\input{sections/onetimesig}
\input{sections/multisig}
\input{sections/benchmarks}
\input{sections/appconstraints}

\begin{acks}
   Nils Fleischhacker was supported by the \grantsponsor{DFG}{Deutsche Forschungsgemeinschaft}{https://www.dfg.de/} (DFG, German Research Foundation) under Germany's Excellence Strategy - \grantnum{DFG}{EXC 2092 CASA - 390781972}.
\end{acks}


%% Bibliography
\bibliographystyle{ACM-Reference-Format}
\bibliography{../cryptobib/abbrev0,../cryptobib/crypto,../extraref}
%\newpage
%\begin{appendix}
%\end{appendix}
\end{document}



