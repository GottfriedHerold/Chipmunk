% !TEX root = ../main.tex

\section{Synchronized Multi-Signatures}\label{sec:nidv}

In this section, we show how the tools developed in the previous sections can be combined to yield a synchronized multi-signature with the desired properties.
We do this in a manner that is almost identical to the way Squirrel~\cite{CCS:FleSimZha22} does it, except that our aggregation is modified to use a rejection sampling technique that allows us to reduce the signature size.
Roughly speaking, a public key in the multi-signature scheme is a vector commitment to a vector of independent one-time signature public keys.
To sign a message at time $t$, the signer publishes an opening to the key in vector position $t$ and signs the message with that key.

To aggregate these signatures, the construction computes a random linear combination of them, using weights derived using a random oracle.
The uniform distribution of weights allows us to leverage the probabilistic homomorphism of the KOTS and HVC schemes, such that this aggregation procedure will be successful with probability at least $1-2\errorbound$.
By rejecting unsuccessful attempts and retrying a number of times, the overall probability of an aggregation failure can be made negligible.

We will now formally define the requirements for a synchronized multi-signature scheme.
Once again, our definitions follow the definitions of Fleischhacker, Simkin, and Zhang \cite{CCS:FleSimZha22}.
In contrast to their work, however, we define a significantly stronger notion of correctness for aggregated signatures.
More concretely, \cite{CCS:FleSimZha22} only required that aggregation is successful for honestly generated keys and signatures.
We, on the other hand, require that any sequence of \emph{individually valid} signatures can be successfully aggregated.\footnote{It is worth noting, that the  \emph{construction} of Squirrel~\cite{CCS:FleSimZha22} actually satisfies this stronger notion. It was just never defined or proven.}

\begin{definition}[Synchronized Multi-Signatures]\label{def:multisig} A synchronized $\rho$-wise multi-signature scheme for $2^\tau$ time periods is defined by six PPT algorithms $\msig=(\setup, \kgen, \sign,\allowbreak \aggregate,\allowbreak \iverify, \averify)$.
\begin{description}
  \item[$\params\gets\setup(\secparam)$] The setup algorithm takes as input the security parameter and outputs public parameters $\params$.
  \item[$(\sk,\pk)\gets\kgen(\params)$] The key generation algorithm takes as input the public parameters and outputs a key-pair.
  \item[$\sigma\gets\sign(\params,\sk,t,m)$] The signing algorithm takes as input the public parameters, a secret key, a time period $1 \leq t \leq 2^\tau $, and a message and outputs a signature.
  \item[$\aggsig\gets\aggregate(\params,\pubkeys,t,m,\signatures)$] The aggregation algorithm takes as input the public parameters, a list of public keys, a time period $1 \leq t \leq 2^\tau$, a message, and a list of signatures, where $\abs{\pubkeys}=\abs{\signatures}\leq\rho$ and outputs an aggregated signature or an error $\bot$.
  \item[$b \gets \iverify(\params,\pk,t,m,\sigma)$] The deterministic individual verification algorithm takes as input the public parameters, a public key, a time period $1 \leq t \leq 2^\tau $, a message, and a signature and outputs a bit indicating acceptance/rejection.
  \item[$b \gets \averify(\params,\pubkeys,t,m,\aggsig)$] The deterministic aggregated verification algorithm takes as input the public parameters, a list of public keys, a time period $1 \leq t \leq 2^\tau$, a message, and an aggregated signature and outputs a bit indicating acceptance/rejection.
\end{description}
\end{definition}

\begin{definition}[Individual Correctness]
  Let $\msig$ be a synchronized $\rho$-wise multi-signature scheme for $2^\tau$ time periods.
  $\msig$ is individually correct if for all security parameters $\secpar\in\NN$, public parameters $\params\gets\setup(\secparam)$, key pairs $(\sk,\pk)\gets\kgen(\params)$, time periods $1 \leq t \leq 2^\tau$, message $m\in\bin^*$, and signatures $\sigma\gets\sign(\params,\sk,t,m)$ it holds that
  \[
    \iverify(\params,\pk,t,m,\sigma) = 1\enspace.
  \]
\end{definition}

\begin{definition}[Aggregation Correctness with Rogue Keys and Signatures]
  Let $\msig$ be a synchronized $\rho$-wise multi-signature scheme for $2^\tau$ time periods.
  $\msig$ has correct aggregations in the presence of rogue keys and signatures if for all security parameters $\secpar\in\NN$, public parameters $\params\gets\setup(\secparam)$, number of aggregated signatures $\ell\in[\rho]$, time periods $1\leq t \leq 2^\tau$, messages $m\in\bin^*$, public keys $\pubkeys = (\pk^1,\dots,\pk^\ell)$ and signatures $\signatures = (\sigma^1,\dots,\sigma^\ell)$, such that for all $i\in[\ell]$, $\iverify(\params,\pk^i,t,m,\sigma^i) = 1$ it holds that
  \begin{align*}
    &\Pr[\aggsig\gets\aggregate(\params,\pubkeys,t,m,\signatures)\colon \averify(\params,\pubkeys,t,m,\aggsig)=1]\\ &=1-\negl\enspace.
  \end{align*}
\end{definition}

\begin{definition}[Unforgeability]\label{def:multisigunforge}
  Let $\msig$ be a synchronized $\rho$-wise multi-signature scheme for $2^\tau$ time periods.
  $\msig$ is unforgeable if for all security parameters $\secpar\in\NN$, and all PPT algorithms $\adv$ it holds that
\[
  \begin{aligned}
  &\Pr\mleft[\begin{aligned}
  \params\gets{}&\setup(\secparam);\\
  (\sk^*,\pk^*)\gets{}&\kgen(\params);\\
  \mleft(
  \begin{aligned}
  &\pubkeys,t,\\&m,\aggsig
  \end{aligned}
  \mright)\gets{}&\adv^{\sign(\sk^*,\cdot,\cdot)}(\params,\pk^*)
  \end{aligned}\!\!\colon\!\!\!\!
  \begin{aligned}
  &\mleft(\begin{aligned}
  &\averify(\params,\pubkeys\!,t,m,\aggsig)\\&=1
  \end{aligned}\mright)\\
  {}\land{}&\pk^*\in\pubkeys\\
  {}\land{}&\mleft(\begin{aligned}
  &\forall\; (t',m',\sigma') \in\queries\ldotp\\&(t',m') \neq (t,m)
  \end{aligned}\mright)\\
  {}\land{}&\forall\; t' \ldotp\;\abs{\queries_{t'}}\leq 1
  \end{aligned}\mright]\\
  &\leq \negl\enspace,
  \end{aligned}
\]
where $\queries$ denotes the set of signing queries made by $\adv$ and $\queries_{t'}$ denotes the set of signing queries made for timeslot $t'$.
\end{definition}

\begin{figure*}
\centering
\begin{pchstack}[center,boxed]
\begin{pcvstack}
  \procedure{$\setup(\secparam)$}{\\[-1.2em]
%    \delta \coloneqq \lceil\log\tau\rceil\\
    \hotsparams\gets\hots.\setup(\secparam)\\
    \hvcparams\gets\hvc.\setup(\secparam)\\
    \pcreturn \params\coloneqq (\hotsparams,\hvcparams)
  }
  \pcvspace
  \procedure{$\kgen(\params)$}{\\[-1.2em]
%    \pcparse \params \pcas (\hotsparams,\hvcparams)\\
    \pcforeach 1 \leq i \leq 2^\tau\\
    \quad(\osk^i,\opk^i) \gets \hots.\kgen(\hotsparams)\\
    \osks = (\osk^1,\dots,\osk^{2^\tau})\\
    \opks = (\opk^1,\dots,\opk^{2^\tau})\\
    \vec{c} \gets \hvc.\commit(\hvcparams,\opks)\\
    \pcreturn (\sk,\pk) \coloneqq ((\osks,\opks),\vec{c})
  }
  \pcvspace
  \procedure{$\sign(\params,\sk,t,m)$}{\\[-1.2em]
    \otsig \gets \hots.\sign(\hotsparams,\osk_t,m)\\
    \vec{d} \gets \hvc.\open(\hvcparams,\vec{c},\opks,t)\\
    \pcreturn \sigma \coloneqq (\otsig,\vec{d})
  }
  \end{pcvstack}
  \pchspace
  \procedure{$\aggregate(\params,\pubkeys,t,m,\signatures)$}{\\[-1.2em]
    \pcif \abs{\signatures} \neq \abs{\pubkeys}\\
    \quad \pcreturn \bot\\
    \pcfor (\pk,\sigma) \in \zip(\pubkeys,\signatures)\\
    \quad \pcif \iverify(\params,\pk,t,m,\sigma) = 0\\
    \quad \quad \pcreturn \bot\\
    j \coloneqq 0\\
    \pcdo[]\\
    \quad j\coloneqq j+1\\
    \quad (w^0,\dots,w^{\abs{\pubkeys}}) \coloneqq H(t,m,\pubkeys,j)\\
    \quad \otsig \coloneqq \sum_{i=1}^{\abs{\pubkeys}} w^i\cdot \otsig^i\\
    \quad \vec{d} \coloneqq \sum_{i=1}^{\abs{\pubkeys}} w^i\cdot \vec{d}^i\\
    \pcwhile j < \chi \pcand \averify(\params,\pubkeys,t,m,(\otsig,\vec{d},j))=0\\
    \pcreturn \aggsig \coloneqq (\otsig,\vec{d},j)
  }
\pchspace
\begin{pcvstack}
  \procedure{$\iverify(\params,\pk,t,m,\sigma)$}{\\[-1.2em]
    \opk \gets \hvc.\sverify(\hvcparams,\vec{c},t,\vec{d})\\
    \pcif t > 2^\tau \pcor \opk = \bot\\
    \quad \pcreturn 0\\
    \pcelse\\
    \quad \pcreturn \hots.\sverify(\hotsparams,\opk,m,\otsig)
  }
  \pcvspace
  \procedure{$\averify(\params,\pubkeys,t,m,\aggsig)$}{\\[-1.2em]
    (w^1,\dots,w^{\abs{\pubkeys}}) \coloneqq H(t,m,\pubkeys,j)\\
    \vec{c} \coloneqq \sum_{i=1}^{\abs{\pubkeys}} w^i\cdot \vec{c}_i\\
    \opk \gets \hvc.\sverify(\hvcparams,\vec{c},t,\vec{d})\\
    \pcif \abs{\pubkeys} > \rho \pcor \opk = \bot\\
    \quad \pcreturn 0\\
    \pcelse\\
    \quad \pcreturn \hots.\sverify(\hotsparams,\opk,m,\otsig)
  }
\end{pcvstack}
\end{pchstack}
%\tikz[remember picture,overlay]{
%    \draw ($(kgen-for-head)+(1ex,-.3\baselineskip)$) -- ($(kgen-for-foot)+(1ex,-.5\baselineskip)$);
%}
\caption{A synchronized multi-signature scheme based on homomorphic vector commitments and key-homomorphic one-time signatures.}
\label{fig:nidvconst}
\end{figure*}
%

\subsection{Construction}
For ease of notation we define the function $\zip$ that \enquote{zips} up two vectors into a single vector of pairs, i.e.
$
\zip(\vec{a},\vec{b}) \coloneqq ((a_1,b_1),\allowbreak\dots,\allowbreak(a_\ell,b_\ell))
$.
The following theorem now states the security of our construction presented in~\autoref{fig:nidvconst}.
\begin{theorem}\label{thm:mainconstruction}
Let $\secpar,n,q',\xi,\chi,\tau$ be positive integers and $0<\errorbound < \tfrac{1}{2}$ with $n$ being a power of two, $q'$ being prime, and $\chi \geq \secpar/\log_2(\frac{1}{2\errorbound})$.
Let $\ring_{q'}$ be the polynomial ring $\defringqq$.
Let $W \subseteq \ring$ be a set such that $\abs{W} > 2^\secpar$ and let $W' \coloneqq \{w^0-w^1| w^0,w^1 \in W\}$.
Let $H \colon\, \bin^* \to W^\rho$ be a random oracle.
Let $\hots$ be a key homomorphic one-time signature scheme with public keys in $\ring_{q'}^\xi$ and let $\hvc$ be a homomorphic vector commitment for domain $\ring_{q'}^\xi$.

If $\hots$ is individually correct, $(\rho,W,\errorbound)$-probabilistically homomorphic, robustly homomorphic, and $W'$-multi-user existentially unforgeable under rerandomized keys and $\hvc$ is individually correct, $(\rho,W,\errorbound)$-probabilistically homomorphic, robustly homomorphic, and position-binding, then the construction from \autoref{fig:nidvconst} is an unforgeable synchronized $\rho$-wise multi-signature scheme that is individually correct and has correct aggregations in the presence of rogue keys and signatures.
\end{theorem}
Due to space constraints the proof of \autoref{thm:mainconstruction} is ommitted.
The proof follows the same ideas as the proof in \cite{CCS:FleSimZha22}, except that we also need to show that aggregation succeeds with high probability.
The proof can be found in the full version~\cite{fullversion} of this work.

%\begin{proof}
%  The theorem follows immediately from \autoref{lem:msigindcorrect}, \ref{lem:msigaggcorrect}, \ref{lem:msigunf} below.
%\end{proof}

Our concrete proposal is to use \eprint{$\hvcencoded$}\cameraready{$\hvccamera$} and $\otschip$ to thereby construct the Chipmunk synchronized multi-signature.
\begin{definition}[Chipmunk synchronized multi-signatures]\label{def:actual_chipmunk}
Let $n, q, q', \eta, \tau, \rho, \alpha_H, \alpha_w, \gamma$ be positive integers, with $n$ being a power of two, $q, q'$ prime.
Let $\ring, \ring_q, \ring_{q'}$ be as usual. We define the synchronized multi-signature Chipmunk, denoted $\msigchip$, by instanciating the construction from \autoref{fig:nidvconst} with \eprint{$\hvcencoded$}\cameraready{$\hvccamera$} with $\xi=2$ and $\otschip$.
\end{definition}
As a corollary of \autoref{thm:mainconstruction}, we obtain that $\msigchip$ is an unforgeable synchronized $\rho$-wise multi-signature that is individually correct and has correct aggregations in the presence of rogue keys and signatures,
provided \eprint{$\hvcencoded$}\cameraready{$\hvccamera$} and $\otschip$ satisfy the appropriate security properties. The latter are guaranteed by \cameraready{\autoref{theo:veccom}}\eprint{\autoref{thm:encodedhvcworks}} and \autoref{theo:kots}, provided we set parameters appropriately and the appropriate Ring-SIS problems are hard.
We collect the neccessary conditions in \autoref{tab:constraints}. Note that $W$ from \autoref{thm:mainconstruction} corresponds to $W = \tern_{\alpha_w}$.

%\bigskip\noindent
%We now proceed to show \autoref{lem:msigindcorrect}, \autoref{lem:msigaggcorrect} and \autoref{lem:msigunf} to actually prove \autoref{thm:mainconstruction}.
%\begin{lemma}\label{lem:msigindcorrect}
%Let $\secpar,n,q',\xi,\chi,\rho,\tau$ be positive integers with $n$ being a power of two, $q'$ being prime.
%Let $\ring_{q'}$ be the polynomial ring $\defringqq$.
%Let $\hots$ be a key-homomorphic one-time signature scheme with public keys in $\ring_{q'}^\xi$ and let $\hvc$ be a homomorphic vector commitment for domain $\ring_{q'}^\xi$.

%If both $\hots$ and $\hvc$ are individually correct, then the construction from \autoref{fig:nidvconst} is individually correct.
%\end{lemma}
%\begin{proof}
%  Let $\params=(\hotsparams,\hvcparams)\gets\setup(\secparam)$, $(\sk,\pk) = ((\osks,\opks),\vec{c})\gets\kgen(\params)$, $1\leq t\leq 2^\tau$,$m\in\bin^*$, and $\sigma = (\otsig,\vec{d}) \gets \sign(\params,\sk,t,m)$.
%  By definition of the signing algorithm it holds that
%  \[
%    \otsig \gets \hots.\sign(\hotsparams,\osk^t,m)
%  \]
%  and 
%  \[
%   \vec{d} \gets \hvc.\open(\hvcparams,\vec{c},\opks,t)
%  \]
%  By definition of the key generation algorithm it further holds that
%  \[
%    (\osk^t,\opk^t) \gets \hots.\kgen(\hotsparams)\enspace.
%  \]
%  From the individual correctness of $\hvc$ and the definition of the individual verification algorithm it follows that
%  \[
%    \opk^t = \opk \gets \hvc.\sverify(\params_\hvc,\vec{c},t,\vec{d})\enspace,
%  \]
%  which finally implies by the individual correctness of $\hots$ that
%  \[
%    \hots.\sverify(\params_\hots,\opk,m,\otsig) = 1\enspace.
%  \]
%  Individual correctness thus follows.
%\end{proof}

%\begin{lemma}\label{lem:msigaggcorrect}
%Let $\secpar,n,q',\xi,\chi,\rho,\tau$ be positive integers and $0 < \errorbound < \tfrac{1}{2}$ with $n$ being a power of two, $q'$ being prime and $\chi \geq \secpar/\log(\tfrac{1}{2\errorbound})$.
%Let $\ring_{q'}$ be the polynomial ring $\defringqq$.
%Let $W \subseteq \ring$ be a set and let $W' \coloneqq \{w^0-w^1| w^0,w^1 \in W\}$.
%Let $H\colon\, \bin^* \to W^\rho$ be a random oracle.
%Let $\hots$ be a key-homomorphic one-time signature scheme with public keys in $\ring_{q'}^\xi$ and let $\hvc$ be a homomorphic vector commitment for domain $\ring_{q'}^\xi$.

%If both $\hots$ and $\hvc$ are $(\rho,W,\errorbound)$-probabilistically homomorphic, then the construction from \autoref{fig:nidvconst} has correct aggregations in the presence of rogue keys and signatures.
%\end{lemma}
%\begin{proof}
%  Let $\params = (\params_\hvc,\params_\hots)\gets\setup(\secparam)$, $\ell \in [\rho]$, $1\leq t\leq 2^\tau$, $m\in\bin^*$, $\pubkeys = (\vec{c}^1,\dots,\vec{c}^\ell)$, and $\signatures = (\sigma^1,\dots,\sigma^\ell)$ with 
%  $\sigma^i=(\otsig,\vec{d})$, be arbitrary, such that for all $i\in[\ell]$, $\iverify(\params,\vec{c}^i,t,m,\sigma^i)$.
%  
%  The aggregation algorithm makes up to $\chi$ attempts to aggregate the signature and will only output an \emph{invalid} signature, if all $\chi$ attempts fail.
%  It thus suffices to analyse the probability with which all attempts fail.
%  
%  Attempt $j$ is performed by computing weights $(w^1,\dots,w^\ell) \coloneqq H(t,m,\pubkeys,j)$ and computing 
%  \[
%    \otsig \coloneqq \sum_{i=1}^{\abs{\pubkeys}} w^i\cdot \otsig_i \quad \text{and}\quad \vec{d} \coloneqq \sum_{i=1}^{\abs{\pubkeys}} w^i\cdot \vec{d}_i\enspace.
%  \]
%  Let $\vec{c} = \sum_{i\in[\ell]}w^i\cdot\vec{c}^i$.
%  Since the signatures individually verify, there exists a well-defined $\opk^i \coloneqq \hvc.\iverify(\params,\vec{c}^i,t,\vec{d}^i)$ for all $i\in[\ell]$.
%  Since further $H$ is a random oracle we can apply the $(\rho,W,\errorbound)$-probabilistic homomorphism of both $\hvc$ of $\hots$ to conclude that
%  \[
%    \Pr\Bigl[\hvc.\sverify(\params_\hvc,\vec{c},t,\vec{d}) \neq \sum_{i\in[\ell]} w^i\cdot\opk^i\Bigr] \leq \errorbound \enspace.
%  \]
%  and
%  \[
%    \Pr\Bigl[\hots.\sverify\Bigl(\params_\hots,\sum_{i\in[\ell]} w^i\cdot\opk^i, m, \otsig\Bigr) = 0\Bigr] \leq \errorbound\enspace.
%  \]
%  The aggregation attempt fails if either of these conditions is violated.
%  Therefore, by a union bound, each individual attempt fails with probability at most $2\errorbound$.
%  Since each attempt is an independent Bernoulli trial the probability of overall failure of all $\chi\geq \secpar/\log_2(\tfrac{1}{2\errorbound})$ attempts can be bounded by $(2\errorbound)^{\chi} \leq 2^{-\secpar}$.
%  Hence, aggregation will succeed with overwhelming probability.
%\end{proof}

%\begin{lemma}\label{lem:msigunf}
%Let $\secpar,n,q',\xi,\chi,\rho,\tau$ be positive integers with $n$ being a power of two, $q'$ being prime.
%Let $\ring_{q'}$ be the polynomial ring $\defringqq$.
%Let $W \subseteq \ring$ be a set such that $\abs{W} > 2^\secpar$ and let $W' \coloneqq \{w^0-w^1| w^0,w^1 \in W\}$.
%Let $H\colon\, \bin^* \to W^\rho$ be a random oracle.
%Let $\hots$ be a key-homomorphic one-time signature scheme with public keys in $\ring_{q'}^\xi$ and let $\hvc$ be a homomorphic vector commitment for domain $\ring_{q'}^\xi$.

%If $\hots$ is $W'$-multi-user existentially unforgeable under rerandomized keys and $\hvc$ is position-binding, then the construction from \autoref{fig:nidvconst} is unforgeable.
%\end{lemma}

%\begin{proof}
%  The proof for this lemma remains essentially identical to the proof of unforgeability for Squirrel~\cite{CCS:FleSimZha22}.
%  The entire argument is only concerned with the \emph{aggregated verification} algorithm, the unforgeability of $\hots$ and the position binding of $\hvc$.
%  None of the differences between Chipmunk and Squirrel affect these parts, with the tiny exception that the random oracle during verification now takes the additional input $j$.
%  Literally, the only necessary change in the proof is, therefore, that during the technically tedious forking lemma setup, the simulated random oracle needs to also take $j\in[\chi]$ as input.
%  As such, we omit the proof here and refer the interested reader to the full version of the original Squirrel paper~\cite{EPRINT:FleSimZha22}.
%  We stress that the proof of unforgeability in \cite{EPRINT:FleSimZha22} relies on a variant \cite{CCS:BelNev06} of the forking lemma \cite{EC:PoiSte96}, which uses a rewinding strategy that does not apply to quantum algorithms.
%\end{proof}
