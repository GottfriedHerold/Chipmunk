% !TEX root = ../main.tex
\section{Introduction}\label{sec:intro}

Multi-signatures~\cite{NEC:ItaNak83,CCS:MicOhtRey01} allow for compressing distinct signatures for the same message generated by different signers into one small aggregated signature.
Such signature schemes are a powerful tool in distributed systems, like blockchains, where parties vouch for the validity of messages on the network by signing them. 
Rather than storing an amount of signatures that is linear in the number of parties that vouched for a specific messages, multi-signatures allow for storing a much shorter string that vouches for a message on behalf of all signers simultaneously.
Popular proof-of-stake blockchains like Ethereum\footnote{\url{https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md\#attestation}} and DFinity\footnote{\url{https://dfinity.org/whitepaper.pdf}} employ multi-signatures at the core of their consensus layer.

The most popular multi-signature scheme used in practice is a construction due to Boneh, Gentry, Lynn, and Shacham~\cite{EC:BGLS03} based on a signature scheme due to Boneh, Lynn, and Shacham (BLS)~\cite{AC:BonLynSha01}.
Their resulting multi-signatures are extremely small, but the security of their construction relies on the assumed hardness of computing discrete logarithms over pairing-friendly groups.
It was shown by Shor~\cite{Shor94} that the discrete logarithm problem can be solved efficiently by quantum computers, meaning that any cryptographic primitive basing its security on such an assumption is insecure in the presence of a quantum adversary.

Luckily, not all computational hardness assumptions are created equal and some seem to remain hard in the presence of quantum adversaries. 
Building multi-signatures from computational hardness assumptions that withstand quantum adversaries is both a theoretically and practically important question.
While it may not be clear, when practically relevant quantum computers will appear, it is important to have secure alternatives for important cryptographic primitives, when the time comes.

One class of cryptographic hardness assumptions that seems to be particularly resilient against quantum adversaries is lattice-based cryptography.
Two of the three post-quantum signature schemes that were standardized by NIST in 2022 base their security on hardness assumptions related to lattices and, not surprisingly, there has also been significant interest in constructing multi-signatures from lattice hardness assumptions~\cite{CANS:ElBStu16,FukHas19,MaJia19,PenDu20,AFRICACRYPT:KanDut20,PROVSEC:FukHas20,PKC:DOTT21,C:BosTakTib22, CCS:FleSimZha22}.
The current multi-signature constructions, however, do still have significant drawbacks that hinder their practical deployment.
The constructions of El Bansarkhani and Sturm~\cite{CANS:ElBStu16} and Ma and Jiang~\cite{MaJia19} assume that the keys of all signers are generated honestly. 
This is not a realistic assumption as an adversarial signer could aim to perform a rogue-key attack by generating a malformed verification key that depends on honest signers' keys and allows for forging aggregated signatures, which falsely claim that both the malicious and the honest parties signed a message that was not actually signed by them.
The scheme of Kansal and Dutta~\cite{AFRICACRYPT:KanDut20} was shown to be insecure by Liu et al.~\cite{EPRINT:LiuTseTso20b}.
The constructions of Fukumitsu and Hasegawa~\cite{FukHas19,PROVSEC:FukHas20}, Ma and Jiang~\cite{MaJia19}, and Peng and Du~\cite{PenDu20}, and Boschini, Takahashi, and Tibouchi~\cite{C:BosTakTib22} all require interaction between the signers for generating a joint multi-signature.
Such an interaction between independent signers is difficult to realize in many distributed systems as the signers may be online at different times and may even not know of each others existence.

Recently, Fleischhacker, Simkin, and Zhang~\cite{CCS:FleSimZha22} presented a multi-signature construction named Squirrel, which allows for non-interactive aggregation and is secure against rogue-key attacks.
They consider a simplified setting, where signer's keys are only able to sign an a-priori bounded number of messages and where signers are synchronized in the sense that aggregation only has to work for signatures that were generated for the same time step and same message.
This simplified setting is still sufficiently strong for most blockchain applications, where signers do not sign more than one message per block and are naturally synchronized by the length of the current chain.
While an a-priori bound on the number of messages that can be signed may seem like a strong limitation, one can simply set this number large enough, e.g. to $2^{24}$ which would allow a signer to sign a message every 10 seconds for 5 years non-stop.
Aiming for $112$ bits of security, their individual signatures are of roughly size $50$ KB and aggregating $4096$ signatures results in a multi-signature of size $771$ KB.

Squirrel represents a significant step forward for multi-signature schemes that are plausibly secure in the presence of a quantum adversary and are concretely efficient.
For real-world practical scenarios their aggregated signatures seem, however, still too large to be really used.
As a point of reference, a full Ethereum block is on average less than $130$ KB large\footnote{\url{https://etherscan.io/chart/blocksize}}, which would mean that one block could not even fit a single multi-signature.

\subsection{Our Contribution}
In this work we present Chipmunk\footnote{Smaller than squirrels, cuter than squirrels.}, a multi-signature scheme in the synchronized setting~\cite{PKC:GenRam06,CCS:AhnGreHoh10,EC:HohWat18,USENIX:DGNW20} with an a-priori bound on the number of signatures that can be issued per key. 
We aim for the exact same setting as Squirrel~\cite{CCS:FleSimZha22}, but provide both theoretical and practical improvements.

On the theoretical side, we strengthen the security notions for multi-signatures by requiring that aggregation involving malformed but verifying adversarial signatures will succeed with high probability. 
In Squirrel aggregation was only required to work for honestly generated individual signatures. 
In principle, their security model would allow an adversary to perform a denial-of-service attack against the signature aggregation procedure by providing a single verifying, but malformed signature.
In a real-world distributed system, such an attack on liveness would be highly problematic.
We strengthen their security definitions to formally ensure that successfully verifying individual signatures will be successfully aggregated, even if they are chosen maliciously. 

On the practical side, our scheme Chipmunk produces smaller individual and aggregated signatures, when compared to Squirrel.
In terms of computational efficiency metrics, Chipmunk either significantly outperforms Squirrel or remains comparable in speed.
In terms of bandwidth, Chipmunk's aggregate signatures are smaller by a factor of $4.8\times$, when compared to Squirrel.
For keys that can generate $2^{24}$ signatures, an individual Chipmunk signatures is $37$ KB and aggregating $8192$ signatures results in an aggregate signature that is $180$ KB large.
%The gap between Chipmunk's and Squirrel's performance increases with an increasing bound on the number of signatures that should issuable with a single key.
%One of Squirrel's main computational bottlenecks was key generation as generating keys that support $2^{21}$ and $2^{26}$ signatures took $4$ minutes and $2$ hours.
%Chipmunk's key generation times are smaller for these parameters by factors of $9 \times$ and $30 \times$.

We have fully implemented Chipmunk and provide extensive benchmarks and comparisons to Squirrel in~\autoref{sec:benchmarks}.
Chipmunk is the most concretely efficient multi-signature based on assumptions that are assumed to remain valid in the presence of a quantum adversary.

\subsection{Technical Overview}

Conceptually, Chipmunk closely follows the blueprint that was introduced by Fleischhacker, Simkin, and Zhang~\cite{CCS:FleSimZha22}.
Recall that in their work and in ours we only aim to issue an a-priori bounded number of signatures, meaning that key generation is parameterized by $\tau$ and produces a public key that can be used to sign $2^\tau$ messages.
Further recall that we are in the synchronized setting, meaning that we only aim to aggregate signatures for the same message that were issued at the same time step.

In Squirrel, each signer's public key $\pk$ is a homomorphic vector commitment of length $2^\tau$, where position $i$ commits to $\pk^i$, which is the public key of a key-homomorphic one-time signature scheme.
To sign message $m$ at time step $i$, the signer opens the commitment $\pk$ to $\pk^i$ at position $i$ and uses the corresponding one-time signing key to sign the message $m$.
The signature is a vector itself that consists of $\pk^i$, the corresponding opening, and the signature of $m$ under this one-time key.
To verify that a message $m$ was signed for time step $i$, the verifier checks that the given public key $\pk^i$ is a valid opening of the $i$-th position of the corresponding signer's public key $\pk$ and that the given signature verifies for message $m$ under the public key $\pk^i$.

Aggregation of such signatures is performed by exploiting the homomorphic properties of the vector commitment and the one-time signature scheme.
To aggregate signatures, roughly speaking, one simply adds up all the individual commitment openings, the one-time keys, and the corresponding one-time signatures.
The homomorphism of the vector commitment scheme ensures that the sum of openings is a valid opening for the sum of committed messages, i.e. the one-time public keys, under the sum of commitments.
The key-homomorphic property of the one-time signature scheme ensures that the sum of signatures for the same message verifies under the sum of one-time public keys.
Chipmunk follows this blueprint, but improves upon all building blocks that are being used and thereby significantly reduces the multi-signature size of Chipmunk.

\paragraph{Key-Homomorphic One-Time Signatures.}
Squirrel uses a key-homomorphic one-time signature scheme that is similar to those of Boneh and Kim~\cite{BonKim2020} and Lyubashevsky and Micciancio~\cite{TCC:LyuMic08}.
The details of the construction are not relevant for now.
For Chipmunk, we use almost the exact same scheme, but observe by carefully inspecting their original security proof that a minor modification of their construction allows for their proof to produce much tighter parameters and thus smaller signatures.

\paragraph{Homomorphic Vector Commitments.}
The vector commitment used by Squirrel is a homomorphic analogue of the classical Merkle tree construction.
To make a Merkle tree homomorphic, the idea is to employ a homomorphic hash function to compute the node's values of the tree.
Now when adding two trees node-wise, one obtains a new valid tree.
Ajtai~\cite{ICALP:Ajtai99} introduced such a homomorphic hash function based on the short integer solution problem.
The main difficulty with using this hash function is the fact that hash output values need to be transformed into valid hash input values in a way that is efficient and maintains the homomorphic properties we would like our tree to have.
Without going into the details, the problem is that inputs for Ajtai's hash function need to have small norm, but outputs have potentially very large norms.
Fleischhacker, Simkin, and Zhang~\cite{CCS:FleSimZha22} solved this problem by effectively performing a binary decomposition of the hash function's output values, which resulted in vectors with infinity norm one, which could then again be used as hash function inputs.
In Chipmunk, we generalize their trick of decomposing values into binary vectors to decomposition into vectors of small norm.
While conceptually simple, we show that this change allows us to significantly reduce the size of our homomorphic vector commitment openings.

\paragraph{Chipmunk Multi-Signatures.}
Our construction of multi-signatures from vector commitments and one-time signatures follows the blueprint that was already outlined above.
One thing we glossed over so far are rogue-key attacks.
If we were to simply add up individual signatures, then our scheme would be susceptible to an adversary that first sees the honest parties public keys and then generates a malicious public key that allows for forging multi-signatures involving honest signers for arbitrary messages.
To avoid this type of attack, the individual signatures are multiplied by randomizer values before being added up.
These randomizing values need to be large enough to be unpredictable for the adversary, but cannot be too large as the multi-signature scheme's efficiency would deteriorate.
In Squirrel, aggregation was a one-shot process.
In Chipmunk, we repeatedly choose fresh randomization values and attempt aggregation until the aggregated signature is ``small enough''.
We show that doing this alllows us to reduce signature size without affecting the security of our construction.



We note that we grossly oversimplified many things in our above overview and that the precise construction and our improvements are more technically involved.
While each individual improvement may seem conceptually simple, they all add up to significantly improved signature sizes, resulting in the by far most efficient multi-signature scheme from lattice assumptions to date.




